# TCP-or-UDP

## 先来补充一些知识
------
### 理解：窗口和滑动窗口
TCP的流量控制
TCP使用窗口机制进行流量控制
什么是窗口？
连接建立时，各端分配一块缓冲区用来存储接收的数据，并将缓冲区的尺寸发送给另一端

接收方发送的确认信息中包含了自己剩余的缓冲区尺寸

剩余缓冲区空间的数量叫做窗口

![](https://github.com/DesperadoH/Articles/raw/master/imgs/TCP-or-UDP/2.png) 


### TCP建立连接（三次握手），释放连接（四次握手，或者两次）

#### TCP报文段首部格式：
序号：本报文段所发送的数据的第一个字节的序号。
确认号ack：期待收到对方下一个报文段的第一个数据字节的序号
确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效
同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。
              若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。
终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接

#### 三次握手（三次联络）

![](https://github.com/DesperadoH/Articles/raw/master/imgs/TCP-or-UDP/1.jpg) 

还要再发送一次确认是为了，防止已失效的连接请求报文段突然又传到了B，因而产生错误。
已失效的报文段：正常情况下：A发出连接请求，但因为丢失了，故而不能收到B的确认。于是A重新发出请求，然后收到确认，建立连接，数据传输完毕后，释放连接，A发了2个，一个丢掉，一个到达，没有“已失效的报文段”
但是，某种情况下，A的第一个在某个节点滞留了，延误到达，本来这是一个早已失效的报文段，但是在A发送第二个，并且得到B的回应，建立了连接以后，这个报文段竟然到达了，于是B就认为，A又发送了一个新的请求，于是发送确认报文段，同意建立连接，假若没有三次的握手，那么这个连接就建立起来了（有一个请求和一个回应），此时，A收到B的确认，但A知道自己并没有发送建立连接的请求，因为不会理睬B的这个确认，于是呢，A也不会发送任何数据，而B呢却以为新的连接建立了起来，一直等待A发送数据给自己，此时B的资源就被白白浪费了。但是采用三次握手的话，A就不发送确认，那么B由于收不到确认，也就知道并没有要求建立连接


#### 简单来说就是：

    1 主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段,
    主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我.

    2 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:
    我已经收到你的请求了,你可以传输数据了;你要用哪佧序列号作为起始数据段来回应我

    3 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:"我已收到回复,我现在要开始传输实际数据了
    这样3次握手就完成了,主机A和主机B 就可以传输数据了.

#### 3次握手的特点

    没有应用层的数据
    SYN这个标志位只有在TCP建产连接时才会被置1
    握手完成后SYN标志位被置0



#### 四次握手（两个二次握手）

B收到连接释放报文段后就立即发送确认，然后就进入close-wait状态，此时TCP服务器进程就通知高层应用进程，因而从A到B的连接就释放了。此时是“半关闭”状态。即A不可以发送给B，但是B可以发送给A。
此时，若B没有数据报要发送给A了，其应用进程就通知TCP释放连接，然后发送给A连接释放报文段，并等待确认。
A发送确认后，进入time-wait，注意，此时TCP连接还没有释放掉，然后经过时间等待计时器设置的2MSL后，A才进入到close状态。
为什么要等待呢?

1、为了保证A发送的最后一个ACK报文段能够到达B。即最后这个确认报文段很有可能丢失，那么B会超时重传，然后A再一次确认，同时启动2MSL计时器，如此下去。如果没有等待时间，发送完确认报文段就立即释放连接的话，B就无法重传了（连接已被释放，任何数据都不能出传了），因而也就收不到确认，就无法按照步骤进入CLOSE状态，即必须收到确认才能close。

2、防止“已失效的连接请求报文段”出现在连接中。经过2MSL，那些在这个连接持续的时间内，产生的所有报文段就可以都从网络中消失。即在这个连接释放的过程中会有一些无效的报文段滞留在楼阁结点，但是呢，经过2MSL这些无效报文段就肯定可以发送到目的地，不会滞留在网络中。这样的话，在下一个连接中就不会出现上一个连接遗留下来的请求报文段了。
可以看出：B结束TCP连接的时间比A早一点，因为B收到确认就断开连接了，而A还得等待2MSL.

#### 简单来说：

    1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求

    2  主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1

    3 由B 端再提出反方向的关闭请求,将FIN置1

    4 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.

由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端
和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础

#### 名词解释

    ACK  TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段
    都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性.

    SYN  同步序列号,TCP建立连接时将这个位置1

    FIN  发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1

#### TCP的包头结构：
    源端口 16位
    目标端口 16位
    序列号 32位
    回应序号 32位
    TCP头长度 4位
    reserved 6位
    控制代码 6位
    窗口大小 16位
    偏移量 16位
    校验和 16位
    选项  32位(可选)
    这样我们得出了TCP包头的最小长度，为20字节。


## UDP（User Data Protocol，用户数据报协议）

（1） UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

（2） 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。

（3） UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。

（4） 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。

（5）UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。

（6）UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。

我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。

#### UDP的包头结构：
    源端口 16位
    目的端口 16位
    长度 16位
    校验和 16位


####小结TCP与UDP的区别：

1.基于连接与无连接；

2.对系统资源的要求（TCP较多，UDP少）；

3.UDP程序结构较简单；

4.流模式与数据报模式 ；

5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。


### 首先咱们弄清楚，TCP协议和UCP协议与TCP/IP协议的联系

很多人犯糊涂了，一直都是说TCP/IP协议与UDP协议的区别，我觉得这是没有从本质上弄清楚网络通信！
TCP/IP协议是一个协议簇。里面包括很多协议的。UDP只是其中的一个。之所以命名为TCP/IP协议，因为TCP,IP协议是两个很重要的协议，就用他两命名了。

TCP/IP协议集包括应用层,传输层，网络层，网络访问层。

#### 其中应用层包括:

超文本传输协议(HTTP):万维网的基本协议. 

文件传输(TFTP简单文件传输协议):   

远程登录(Telnet),提供远程访问其它主机功能,它允许用户登录 

internet主机,并在这台主机上执行命令.   

网络管理(SNMP简单网络管理协议),该协议提供了监控网络设备的方法,以及配置管理,统计信息收集,性能管理及安全管理等.

域名系统(DNS),该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址. 

#### 其次网络层包括:  

Internet协议(IP) 

Internet控制信息协议(ICMP)    

地址解析协议(ARP)   

反向地址解析协议(RARP)  

#### 最后说网络访问层:
网络访问层又称作主机到网络层(host-to-network).网络访问层的功能包括IP地址与物理地址硬件的映射,以及将IP封装成帧.基于不同硬件类型的网络接口,网络访问层定义了和物理介质的连接.

## 区别

很多文章都说TCP协议可靠，UDP协议不可靠！为什么前者可靠，后者不可靠呢？既然UDP协议不可靠，为什么还要使用它呢？所谓的TCP协议是面向连接的协议，面向连接是什么呢？   
TCP和UDP都是传输层的协议！从编程的角度看，就是两个模块（模块就是代码的集合，一系列代码的组合提供相应的功能！模块化最终目的就是：分工协作！模块化好处：便于扩展开发以及维护！）。   
先说TCP协议：   

这个协议，是面向的连接！面向连接这个概念，我们要从物理层看起。大家都知道，因为“信道复用技术”的迅猛发展，才促使了计算机网络的发展！如果没有“信道复用技术”，那么单条线路上（这里的线路指物理传输介质，例如：双绞线、光纤、电话线）单位时间内只能供一台计算机使用！还是举例说明：就拿你自己的计算机来说，你跟同学“小明”聊天的时候，就不能跟另外一位同学“小强”聊天，如果你想同时跟两位同学聊天，那么你就得装两条线路！那么同时与第三位、第四位同学。。。第N位同学聊天的时候，你需要装几根线路？全世界人民聊天的时候，又需要装几根线路？   
“信道复用技术”实现了，在同一条线路上，单位时间内可供X台计算机同时通信！Toad知道以下几种复用技术：   

  1、频分复用    2、时分复用    3、波分复用    4、码分复用    5、空分复用    6、统计复用    7、极化波复用  
  
关于“信道复用技术”更深层次的问题，需要你自己去研究！   
上面我们提到了“信道复用技术”！知道了这一点，我们就很容易明白“物理信道”上的“虚拟信道”概念了！不同的信道复用技术，使用不同的复用技术，目的就是创建“虚拟信道”。   
一个TCP协议连接其实就是在物理线路上创建的一条“虚拟信道”。这条“虚拟信道”建立后，在TCP协议发出FIN包之前（两个终端都会向对方发送一个FIN包），是不会释放的。正因为这一点，TCP协议被称为面向连接的协议！   


UDP协议，一样会在物理线路上创建一条“虚拟信道”，否则UDP协议无法传输数据！但是，当UDP协议传完数据后，这条“虚拟信道”就被立即注销了！因此，称UDP是不面向连接的协议！
TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。

## TCP协议和UDP协议为什么会共存?

1. 大家要知道，一种物理线路，单位时间内，能够创建的“虚拟信道”是有限的！

2. 使用TCP协议传输数据，当数据从A端传到B端后，B端会发送一个确认包（ACK包）给A端，告知A端数据我已收到！UDP协议就没有这种确认机制！这就是为什么说TCP协议可靠，UDP协议不可靠. 

QQ普通会员就是使用的UDP协议进行传输数据！既然UDP协议自身没有确认机制，这个工作可以交给应用层的进程来完成（QQ）！大家使用QQ的时候，感觉出错的几率还是非常小吧！当然，把这个确认工作完全交给QQ自身来做，就直接导致了，QQ软件体积增大！   

 

有些应用，对数据传输可靠性要求非常高，例如大家浏览网页，通过网页注册帐号、转帐等服务，这是不容许出错的，使用TCP协议能把出错的可能性降到最低（当然，网络自身很糟糕，TCP协议也没办法）。但是，提供这种可靠服务，会加大网络带宽的开销，因为“虚拟信道”是持续存在的，同时网络中还会出现大量的ACK和FIN包！  

  因此，鱼和熊掌不可兼得，需根据实际情况选择传输协议.TCP协议提供了可靠的数据传输,但是其拥塞控制、数据校验、重传机制的网络开销很大,不适合实时通信,所以选择开销很小的UDP协议来传输数据。   

UDP 协议是无连接的数据传输协议并且无重传机制,会发生丢包、收到重复包、乱序等情况。而对于数据精确性要求不高的状态数据以及视频数据,丢包的影响不大。因为会不断收到新的包,丢失的个别包会有新的包来覆盖,所以只需在远程控制系统的通信部分自行处理乱序及重复包的问题,而对于丢包的问题一般不作处理。    但对于命令包这种需要精确收发的数据, 可在程序的开发中加入丢包重发和超时丢弃的处理。 当然,如果开发的是对于实时性要求不高的事件型控制命令的传输,不希望发生指令的丢失也可以直接采用TCP协议。TCP的重传机制正好适合这种情况。   

 

非面向连接的传输协议在数据传输之前不建立连接，而是在每个中间节点对非面向连接的包和数据包进行路由。没有点到点的连接，非面向连接的协议，如UDP，是不可靠的连接。当一个UDP数据包在网络中移动时，发送过程并不知道它是否到达了目的地，除非应用层已经确认了它已到达的事实。非面向连接的协议也不能探测重复的和乱序的包。标准的专业术语用“不可靠”来描述UDP。在现代网络中，UDP并不易于导致传输失败，但是你也不能肯定地说它是可靠的


TCP和UDP都是传输层的协议！

应用层 （QQ）

物理连接层

各自协议使用的常用端口：如http, https, tcp, udp, ftp等等

TCP:
FTP:21, Telnet:23, SMTP:25

UDP:
DNS:53, TFTP:69, SNMP:161, RIP:520

https:
http:80


## 为什么 UDP 有时比 TCP 更有优势

随着网络技术飞速发展，网速已不再是传输的瓶颈，UDP协议以其简单、传输快的优势，在越来越多场景下取代了TCP，如网页浏览、流媒体、实时游戏、物联网。

### 1.网速的提升给UDP稳定性提供可靠网络保障

CDN服务商Akamai（NASDAQ: AKAM）报告从2008年到2015年7年时间，各个国家网络平均速率由1.5Mbps提升为5.1Mbps，网速提升近4倍。网络环境变好，网络传输的延迟、稳定性也随之改善，UDP的丢包率低于5%，如果再使用应用层重传，能够完全确保传输的可靠性。

### 2.对比测试结果UDP性能优于TCP

为了提升浏览速度，Google基于TCP提出了SPDY协议以及HTTP/2。Google在Chrome上实验基于UDP的QUIC协议，传输速率减少到100ms以内。

Google采用QUIC后连接速率能有效提升75%。
Google搜索采用QUIC后页面加载性能提升3%。
YouTube采用QUIC后重新缓冲次数减少了30%。

### 3.TCP设计过于冗余，速度难以进一步提升

TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程以及重传策略。由于TCP内置在系统协议栈中，极难对其进行改进。

### 4.UDP协议以其简单、传输快的优势，在越来越多场景下取代了TCP

#### 4.1 网页浏览

使用UDP协议有三个优点 ：

>能够对握手过程进行精简，减少网络通信往返次数；

>能够对TLS加解密过程进行优化；

>收发快速，无阻塞。


#### 4.2 流媒体

采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送，延迟会越来越大。基于UDP的协议如WebRTC是极佳的选择。

2010年google 通过收购 Global IP Solutions，获得了WebRTC（网页实时通信，Web Real-Time Communication）技术，用于提升网页视频速率。

#### 4.3 实时游戏

对实时要求较为严格的情况下，采用自定义的可靠UDP协议，比如Enet、RakNet（用户有sony online game、minecraft）等，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。
采用UDP的经典游戏如FPS游戏Quake、CS，著名的游戏引擎Unity3D采用的也是RakNet。

#### 4.4 物联网

2014年google旗下的Nest建立Thread Group，推出了物联网通信协议Thread，完善物联网通信。

采用UDP有3个关键点：

网络带宽需求较小，而实时性要求高；

大部分应用无需维持连接；

需要低功耗。



